# Bayesian Inference of Natural Selection from Allele Frequency Time Series
We are going to use the Bayesian Markov Chain Monte Carlo (MCMC) method `sr` developed by 
[Schraiber et al. (2016)](https://doi.org/10.1534/genetics.116.187278), and will attempt to recreate the main findings
of selection on *MC1R* from their paper:

![Figure 6](https://www.genetics.org/content/genetics/203/1/493/F6.large.jpg "Figure 6")
**Figure 6.** (A and B) Posterior distribution on allele frequency paths for the MC1R locus. Each panel shows the sampled 
allele frequency data (solid circles), the point-wise median (black), 25% and 75% quantiles (red), and 5% and 95% quantiles 
(green) of the posterior distribution on paths and the posterior distribution on allele age (blue). A) reports inference 
with constant demography, and B) shows the result of inference with the full demographic history.

## Download and compile `sr`

Download the source code from GitHub
```
git clone https://github.com/Schraiber/selection && cd selection
```

Since the paper was released in 2016 there have been various updates to the code, so we will checkout an older version 
that is compatible with the analysis described in the paper.

```
git checkout change_time_parameters
```

Then compile the software for the current environment
```
g++ -O3 *.cpp -lgsl -lgslcblas -lm -o sr
```

If you encounter any compilation errors, the [README](https://github.com/Schraiber/selection/tree/change_time_parameters) file has some additional 
instructions which might help. If everything has worked, then you should have a new binary file in the current directory 
called `sr`

Try running the program with no flags to confirm that it is working
```
./sr
```
    No task specified
    -b x0,xt,gamma,t for bridge path
    -X x0,x1,...,xn -N n0,n1,...nn -T t0,t1,...tn for mcmc with just allele frequencies

## Prepare the input data

In the main text, [Schraiber et al. (2016)](https://doi.org/10.1534/genetics.116.187278) reanalysed data from two horse 
coat colour genes, *MC1R* and *ASIP*, which was generated by [Ludwig et al. (2009)](https://doi.org/10.1126/science.1172750).

| Sample   time (years BCE) | Sample time (diffusion units) | Sample size | Count of ASIP alleles | Count of MC1R alleles |
|---------------------------|-------------------------------|-------------|-----------------------|-----------------------|
| 20,000                    | 0.078                         | 10          | 0                     | 0                     |
| 13,100                    | 0.051                         | 22          | 1                     | 0                     |
| 3,700                     | 0.014                         | 20          | 15                    | 1                     |
| 2,800                     | 0.011                         | 20          | 12                    | 6                     |
| 1,100                     | 0.004                         | 36          | 15                    | 13                    |
| 500                       | 0.002                         | 38          | 18                    | 24                    |

[Table 2.](https://www.genetics.org/content/203/1/493#T2) Sample information for horse data. Diffusion time units are 
calculated assuming *N*<sub>0</sub>=2500 and a generation time of 5 years. BCE, Before Common Era.

The data has been grouped into time bins, with multiple haploid observations at each time point.

The input format for `sr` is a tab-delimited text file, with no header, and four columns:

1. The number of derived alleles
2. The sample size (in haploid genomes)
3. The most recent end of the possible age of the sample (i.e. the youngest it could be)
4. The most ancient end of the possible age of the sample (i.e. the oldest it could be)

Create an input file for the *MC1R* data, called `horse-MC1R.txt`, using years BCE as the date format (dates should always be negative).

For example, the first two lines should look like this:
```
0	10	-20000	-20000
0	22	-13100	-13100
```

The easiest way to manually create this file is to use the `nano` text editor. Alternatively, you can download my copy of the file:

```
wget https://raw.githubusercontent.com/ekirving/temporal-selection/main/exercises/data/horse-MC1R.txt
```

## Running the model

To infer selection on the *MC1R* data, we can use either the constant population demographic model (`-P constant.pop`) 
or use the complex demographic history inferred in [Der Sarkissian et al. (2015)](https://doi.org/10.1016/j.cub.2015.08.032) 
(`-P horse.all.pop`). One of the main arguments made in [Schraiber et al. (2016)](https://doi.org/10.1534/genetics.116.187278) 
is that misspecification of the demographic history can substantially bias inference of selection (see Figure 6).

Because we specified sample ages in units of calendar years, we need to provide a generation time (`-G 5`) and a reference 
population size (`-N 2500`) so `sr` can perform the conversion to diffusion units. Diffusion units are a scaling of time 
relative to the reference population size (*N*<sub>0</sub>=2500) and the generation time (5 years), such that 
`diff_units = calendar_years / ( 2 * Nref * gen_time)`

In the main text, Schraiber describes their other choice of parameters as:

> We then ran the MCMC algorithm for 1,000,000 generations, sampling every 1000 generations to obtain 1000 MCMC samples for each simulation.

Given these parameter choices, we can run the inference for the constant population model:
```
./sr -D horse-MC1R.txt \
     -P constant.pop \
     -G 5 \
     -N 2500 \
     -n 1000000 \
     -s 1000 \
     -a \
     -o horse-MC1R-const-pop
```

If you get the following error, please ensure that you have created the file `horse-MC1R.txt` and that it is formatted correctly.
```
ERROR: Final time point is not infinity OR final epoch not constant
```

Because the MCMC has to run for 1 million generations, this can take 5-10 minutes to run on a reasonably fast CPU.

For a full list of the available flags, see the [README](https://github.com/Schraiber/selection/tree/change_time_parameters) file.

## Checking model diagnostics

When running an MCMC analysis, there is a possibility that the chain has not mixed effectively and that not all parameters
of interest have been well sampled from. One method for testing this is to calculate the Effective Sample Size (ESS) of each
parameter inferred by the MCMC. In their paper, Schraiber *et al.* use a minimum ESS of 150 as a cut-off for their simulations, but do not describe what
value they used for the empirical data.

> After discarding the first 500 samples from each MCMC run as burn-in, we computed the effective sample size of the 
> allele age estimate, using the R package coda [(Plummer et al. 2006)](https://cran.r-project.org/package=coda).

[comment]: <> (conda env create --name temporal --file environment.yaml)
[comment]: <> (conda activate temporal)

Firstly, open an `R` session:
```
R
```
Then load the data and calculate the ESS
```R
library(coda)

# load the model parameters
param <- read.delim("horse-MC1R-const-pop.param")

# discard the first 500 observations as a burn-in
param.burn <- param[-c(1:500),]

# calculate the ESS for the five parameters of interest
effectiveSize(param.burn[c("lnL", "pathlnL", "alpha1", "alpha2", "age")])
```

Did all of your parameters pass the ESS > 150 threshold? If not, what steps can we take to improve the ESS?

## Plotting the inferred trajectory

In the source code for `sr` there is a helper script `path_utilities.r` which contains the plotting functions used to
make Figure 6 from the main text.

```R
# load the helper script
source("path_utilities.r")

# load the MCMC output (the can take a little while)
paths <- read.path("horse-MC1R-const-pop")

# load the sample data
samples <- read.delim("horse-MC1R.txt", header=FALSE, col.names = c('derived_count', 'sample_size', 'age_youngest', 'age_oldest'))

# convert the counts into frequencies
sam_freqs <- samples$derived_count / samples$sample_size

nref = 2500
gen_time = 5

# convert the mid-point age into diffusion units
sam_times <- rowMeans(samples[c('age_youngest', 'age_oldest')]) / (2*nref*gen_time)

# plot the trajectory to a PDF file
pdf(file = "horse-MC1R-const-pop-traj.pdf", width=8, height=5)
plot.posterior.paths(paths, sam_freqs, sam_times, burnin = 500, xlim=c(min(sam_times), 0))
dev.off()
```

If you don't have X11 forwarding enabled in your SSH session, you can view the figure by copying it to your local machine 
with `scp`.

Does your trajectory look the same as Figure 6A from the paper? Does it look the same as other students' in the class? 
If not, why might this be?

## Plotting the posterior estimates

In addition to the trajectory itself, `sr` infers the `age` of the allele, the heterozygote fitness `alpha1` , and 
the homozygote fitness `alpha2`.

```R
# convert `alpha` into `s` (where alpha = 2*Ne*s)
s1 <- param.burn$alpha1 / (2*nref)
s2 <- param.burn$alpha2 / (2*nref)

# plot the posteriors for s1 and s2
pdf(file = "horse-MC1R-const-pop-s1.pdf", width=8, height=5)
plot(density(s1))
dev.off()

pdf(file = "horse-MC1R-const-pop-s2.pdf", width=8, height=5)
plot(density(s2))
dev.off()

# convert diffusion units into calendar years
age <- param.burn$age * (2*nref*gen_time)

# plot the posterior for the age of the allele
pdf(file = "horse-MC1R-const-pop-age.pdf", width=8, height=5)
plot(density(age))
dev.off()
```

How does the inferred age of the *MC1R* allele compare with archaeological evidence for the earliest horse management
and directed breeding?

## Optional Extra

Trying repeating these steps for the model with the complex demography (`-P horse.all.pop`).

What effect did this have on the ESS for the inferred params? How might we improve on this?

How do the posterior densities of the age of the allele and the selection coefficients differ from the constant population
model?